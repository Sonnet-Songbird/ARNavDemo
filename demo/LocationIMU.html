<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>A-Frame Location Example</title>
    <script src="../aframe/build/aframe.min.js"></script>
    <!-- Assumes AR.js build is in the 'AR.js' directory -->
    <script type='text/javascript' src='../three.js/build/ar-threex-location-only.js'></script>
    <script type='text/javascript' src='../aframe/build/aframe-ar.js'></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src='index.js'></script>
</head>
<body>
    <a-scene environment="preset: default;">

        <a-entity id="mouseCursor" cursor="rayOrigin: mouse"></a-entity>

        <a-entity id="hand" laser-controls="hand: right">
            <a-sphere radius="0.03"></a-sphere>
        </a-entity>

        <a-sphere id="sphere" radius="2" position="0 2 -20" color="gray"></a-sphere>

    </a-scene>
    <div id='setloc'
         style='position:absolute; left: 10px; bottom: 2%; z-index:999; background-color: blue; color: white; padding: 10px'>
        <p id="description">현재 엔티티는 시작 지점을 기준으로 20미터 떨어져 있으며, 반경 2미터의 구체입니다.</p>
        <p id="location">.</p>
        <input type='button'
               id='toggle'
               onclick="toggleTrace(this)"
               value='startTrace'
               style="width: 150px; height: 50px; font-size: 16px; position: relative; right: 10px; top: 10px;"/>
    </div>
</body>


<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
    let rotation = {
        alpha: 0, beta: 0, gamma: 0
    };

    const z = [
        {
            position: 0,
            velocity: 0,
            acceleration: 0,
            time: undefined
        }
    ];

    const phone = d3.select('#phone');

    window.addEventListener('devicemotion', handleMotion);
    window.addEventListener('deviceorientation', handleOrientation);
    window.addEventListener('mousemove', handleMousemove);

    d3.timer(renderState);
    d3.interval(renderHistory, 500);

    function handleOrientation(e) {
        if (e.gamma === null || e.beta === null || e.alpha === null) return;
        rotation = {
            gamma: e.gamma || 0,
            beta: e.beta || 0,
            alpha: e.alpha || 0
        }
    }

    function handleMotion(e) {
        if (e.acceleration.x === null || e.acceleration.y === null || e.acceleration.z === null) return;
        accelerate(e.acceleration.z, e.timeStamp);
    }

    function handleMousemove(e) {
        var mouseAccelerator = d3.scaleLinear()
            .domain([0, innerWidth])
            .range([-.2, .2]);
        accelerate(mouseAccelerator(e.pageX), e.timeStamp);
        console.log(mouseAccelerator(e.pageX));
    }

    function accelerate(a, t) {

        var newZ = Object.assign({}, z[0]);

        newZ.acceleration = Math.abs(a) > .1 ? a : 0; // noise filter
        newZ.time = t;
        newZ = eulerStep(z[0], newZ);

        newZ.velocity *= .9; // friction
        newZ.velocity = Math.abs(newZ.velocity) < .01 ? 0 : newZ.velocity; // noise filter
        newZ.position *= .999; // tend back to zero

        z.unshift(newZ);
    }

    function eulerStep(state0, state1) {
        var interval = (state1.time - state0.time) / 1000; // convert ms to s
        if (interval) {
            state1.position = state0.position + state0.velocity * interval;
            state1.velocity = state0.velocity + state0.acceleration * interval;
        }
        return Object.assign({}, state1);
    }

    function renderState() {
        phone.style('transform', ''
            // + 'rotateZ('+rotation.alpha+'deg) '
            + 'rotateX(' + rotation.beta + 'deg) '
            + 'rotateY(' + rotation.gamma + 'deg) '
            + 'translate3d(' + 0 + 'px,' + 0 + 'px,' + (-z[0].position * 1000) + 'px)'
        );
    }

    function renderHistory() {

        var data = ['position', 'velocity', 'acceleration'].map(function (d, i) {
            return z.filter(function (dd) {
                return dd.time;
            }).map(function (dd, ii) {
                return {
                    'value': dd[d],
                    'time': dd.time
                }
            });
        });

        var svg = d3.select('svg');

        var x = d3.scaleLinear()
            .domain(d3.extent(d3.merge(data), function (d) {
                return d.time;
            }))
            .range([0, svg.node().getBoundingClientRect().width]);

        var y = d3.scaleLinear()
            .domain(d3.extent(d3.merge(data), function (d) {
                return d.value;
            }))
            .range([0, svg.node().getBoundingClientRect().height]);

        var line = d3.line()
            .x(function (d, i) {
                return x(d.time);
            })
            .y(function (d, i) {
                locationOffset = d.value
                return y(d.value);
            });


        var path = svg.selectAll('path')
            .data(data);

        path.enter().append('path')
            .style('stroke', function (d, i) {
                var colors = {
                    0: 'red', 	//position
                    1: 'green',	//velocity
                    2: 'blue'		//acceleration
                }
                return colors[i];
            });

        path.attr('d', line);


    }


    let trace = false
    const dsec = document.querySelector("#description");
    const loc = document.querySelector("#location");
    const cam = document.querySelector("[camera]");
    setInterval(updateLoc = () => {

        const position = cam.getAttribute('position')
        console.log(position)
        loc.innerHTML = `현재 위치는 ${position.x},${position.y}입니다.`
    }, 500)

    function toggleTrace(button) {
        trace = !trace;
        button.value = trace ? 'endTrace' : 'startTrace';
    }

    let orientation = 0;
    let locationOffset = 0;
    let locationOffsetBefore = 0;

    AFRAME.registerComponent('rotation-reader', {
        tick: function () {
            if (!trace) {
                const position = this.el.getAttribute('position')
                position.x = 0;
                position.y = 0;
                this.el.setAttribute('position', position)

                return;
            }
            const rotation = this.el.getAttribute('rotation');
            console.log(rotation)
            console.log(locationOffset)

            function calc(value) {
                const modulo = value % 360
                if (Math.abs(modulo) > 180) {
                    return modulo * -1
                }
                return modulo
            }

            function popOffset() {
                return locationOffsetBefore + locationOffset
            }

            function moveCoordinates(currentX, currentY, directionDegree, distance) {
                const directionRadian = directionDegree * Math.PI / 180;
                const newX = currentX + (distance * Math.sin(directionRadian));
                const newY = currentY + (distance * Math.cos(directionRadian));
                return {x: newX, y: newY};
            }

            const y = calc(rotation.y)
            const yOrientation = y;

            const position = this.el.getAttribute('position')
            const offset = popOffset() * 3
            const newPos = moveCoordinates(position.x, position.y, yOrientation, offset)
            position.x = newPos.x
            position.y = newPos.y
            this.el.setAttribute('position', position)
        }
    });


    {
        cam.setAttribute(`rotation-reader`, "123")
    }
</script>
</html>
