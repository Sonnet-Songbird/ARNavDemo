<!-- 레이더 데이터는 매 틱마다 SQL DB에서 가져오면 오버헤드도 DB에의 부하도 심하니까 전체 위치 데이터를 가진 캐시 서버나 로컬 캐시에서 받아오는 게 나음 -->
<!-- 아직 작업 중

<!DOCTYPE html>
<html>
<head>
    <title>A-Frame Click Example</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script type='text/javascript' src='../three.js/build/ar-threex-location-only.js'></script>
    <script type='text/javascript' src='../aframe/build/aframe-ar-nft.js'></script>
    <script type="text/javascript" src="./coordinate.js"></script>

</head>
<body>

    <canvas id="radarChart" width="400" height="400"></canvas>


    <a-scene
            embedded
            vr-mode-ui="enabled: false"
            cursor='rayOrigin: mouse'
            raycaster='near: 0; far: 50000'
            arjs='sourceType: webcam; videoTexture: true; debugUIEnabled: false;'
            renderer='antialias: true; alpha: true'
    >

        <a-camera gps-new-camera='simulateLatitude: 51.049; simulateLongitude: -0.723'></a-camera>
        <a-box gps-new-entity-place='latitude: 51.0596; longitude: -0.7170' color='red' scale='200 200 200'
               clicker></a-box>
    </a-scene>
</body>

<script>
    let curruntCoordinate
    let curruntBearing
    window.onload = function () {
        const canvas = document.getElementById('radarChart');
        const ctx = canvas.getContext('2d');

        drawRadarChart(ctx, canvas.width / 2, canvas.height / 2, 150, 3);

        const pointX = 100;
        const pointY = -50;

        drawPoint(ctx, canvas.width / 2, canvas.height / 2, pointX, pointY, 3, 'red');
    };

    function drawRadarChart(ctx, centerX, centerY, radius, numCircles) {
        for (var i = numCircles; i > 0; i--) {
            var circleRadius = radius / numCircles * i;
            ctx.beginPath();
            ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
    }

    function drawPoint(ctx, centerX, centerY, x, y, radius, color) {
        ctx.beginPath();
        ctx.arc(centerX + x, centerY + y, radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
    }


    const updatePosition = () => {

    }

    function isInFov(bearing, fov, originLat, originLong, targetLat, targetLong) {

// 지리 좌표계 상의 상대 위치
        const dLat = targetLat - originLat;
        const dLon = targetLong - originLong;

// 쉬운 계산을 위해 라디안 데카르트 좌표계로 변환
        const dx = dLon * 111.32 * Math.cos((originLat + targetLat) / 2 * Math.PI / 180);
        const dy = dLat * 111.32;


        const targetAngle = Math.atan2(dy, dx) * 180.0 / Math.PI;

        const fovStart = bearing - (fov / 2);
        const fovEnd = bearing + (fov / 2);

        return (fovStart <= targetAngle && targetAngle <= fovEnd);
    }
</script>
</html>

-->
